**Task:**Please find or propose at least two different approaches on how to estimate the time needed to resolve the task given its current state. Write 2-3 sentences about each approach. You can use English or Russian for your answer.

**Описание решений**
В каждой компании внутренние процессы отличаются друг от друга, и поиски унифицированных решений для задачи предсказания времени на решение issues / bug сводится на нет. Поэтому приведу несколько интересных найденных, на мой взгляд, статей и вкратце расскажу, как авторы справлялись с проблемой.

1. В блоге SAP девушка data scientist [написала статью](https://blogs.sap.com/2019/06/18/how-machine-learning-helps-predict-the-time-to-completion-of-a-ticket/) в июне 2019 о решении задачи с помощью ML. В качестве данных используются индивидуальные наборы данных клиентов (компании). Отмечается, что наиболее сложным этапом была именно работа с этими данными, где указаны лишь такие признаки как: кто создал ticket, кто его назначил, какая категория, когда он был создан, а также его приоритет. Было обучено 2 модели: регрессионная для предсказания точного времени на непрерывной временной шкале и классификационная (бустинговые деревья решений) для предсказания диапазона. Наиболее важной оказалась классификационная, т.к. интервал времени для оценки оказывается важнее, чем точное время. В конечном счете они смогли добиться точности 60-70%.

2. В статье [Predicting trouble ticker resolution / 2018 год](https://aaai.org/ocs/index.php/FLAIRS/FLAIRS18/paper/view/17678/16882) также решается 2 задачи: регрессия и классификация. Авторы использовали бустинговые деревья в нейронную сеть, состоящую из входного слоя, 2-ух скрытых Dense слоев и выхода (1 - для регрессии, softmax - для классификация). для классификация использовали 3 класса промежутков времени : 1) < 24 часов;   2) 24 - 120 часов;   3) 120 часов.  Большая часть попадала в промежуток 24 - 120 часов, как в тестовых данных, так и тренировочных, что, как мне кажется, является большим диапазоном оценки. Скорее всего было бы лучше использовать тогда уж промежутки: 1) 0 - 24   2) 24 - 72  3) 72 - 120   4) 120 <. Так было бы корректнее и оценка времени была бы полезнее.

3. Не совсем оценка времени, а некоторая классификация tickets от пользователей в компании Uber. Статья COTA: [Improving the speed and accuracy of customer support through ranking and Deep network](https://arxiv.org/pdf/1807.01337.pdf). Из ticket с помощью NLP извлекаются следующие данные: сообщение, метаданные (время отправки, продукт, и т.д.), информация о пользователе (водитель, пользователь) и др. Далее, данные преобразуются, составляется вектор слов, происходит классификация с помощью вычисления косинусного расстояния.

4. В статье [Predicting Bug-fixing time: an empirical study of commercial software projects (2013)](https://ieeexplore.ieee.org/document/6606654) авторы решают 3 задачи: 

    - предсказывают какое количество багов может быть исправлено 

    - сколько в общем времени требуется для исправления (на проект) 

    - сколько времени требуется на исправление одного бага (здесь решается задача классификации: быстро или медленно...). 
    
    Использовались данные: отправитель, кто ответственен за починку, приоритет, категория, кто обнаружил (разработчики или внешние пользователи), краткое описание. Для общей оценки времени использовалась модель Маркова, для классификации - KNN. Авторы построили важность признаков. Важными оказались информация об ответственном человеке, отправителе и категория бага. Также сообщается, что классификация не всегда работала корректно, т.к. некоторые баги имели одинаковые категории, а время на исправление у одного из них требовалось намного больше.


**Свои мысли**
Попробую описать свои предложения как вижу работу над этой задачей, не имея представления о форме данных и всех шагов от постановки проблемы (нахождения issue) до её решения. 

Допустим, все начинается с того, что клиент находит ошибку или предлагает свою feature. Далее, происходит обсуждение деталей проблемы / дальнейшего видения конечной реализации, после чего формируется ТЗ. На этом этапе, как понимаю, нужно попробовать оценить время, требуемое на реализацию, чтобы дать примерную оценку клиенту, знать разработчику, планировать дальнейшие задачи для разработчиков, так и составлять планы по проектам.

Если все идет примерно по такому пути, то главным источником для оценки времени является составленное ТЗ, т.е. придется работать с текстом, извлекать ключевые слова, производить lemming, stemming, удалять stop-words, составлять некоторый вектор слов. Если с каждым ТЗ нет рядом меток (как, например, на github - issue, bug, urgent and so on), то придется классифицировать по ключевым словам, чтобы нагляднее было видно к какому роду относится issue, например, с помощью методов кластеризации.

Процесс оценки времени будет зависеть от уже имеющихся данных. Наверняка есть различные метрики оценки разработки из разряда, что приведены [здесь](https://www.qasymphony.com/blog/64-test-metrics/) и [здесь](https://www.thinksys.com/qa-testing/software-testing-metrics-kpis/). Их можно использовать в качестве признаков, характеризующих каждую задачу и процесс её реализации. Если есть какие-то важные уточнения, то также можно дополнить признаки вручную. При работе с уже выполненными тасками, также можно попробовать ассоциировать ТЗ (если они сохранились) с полученными ключевыми словами, только теперь уже со временем выполнения или какими-то другими метриками, тем самым попробовать вывести соотношения (ключевое слово - ~время (часы/минуты/дни и т.д.)). Такая оценка будет в своем роде некоторой интерпретацией. Затем попробовать применить некоторый алгоритм, который бы оптимизировал предсказанное время. Может потребоваться некоторое время или необходимость на разметку разработчиками примерного требуемого времени в целом / по категориям, т.к. они технически понимают лучше требуемую задачу. Чтобы статистически их оценка была верна, нужно брать среднее время по оценкам от нескольких разработчиков. Ранжировать issues можно используя соотношения TTR и приоритетности, например 0.2 * TTR + 0.8 * Priority. Также имеет смысл воспользоваться features из данных, которые использовались для оценки важности задач. Наверняка, половина и больше пригодятся для оценки времени. И вообще лучше всего давать оценку времени в виде интервала, так будет корректнее на мой взгляд, несмотря на возможность дать точную оценку с помощью регрессионных ML алгоритмов.

В качестве алгоритмов обучения можно попробовать использовать деревья решений для решения задачи регрессии, т.к. они одни из самых интерпретируемых. В catboost есть feature importance. Можно вообще многомерную линейную регрессию. Можно поискать и попробовать различные способы интерпретации даже попытаться для нейронных сетей - все зависит от алгоритмов, данных и других факторов.
